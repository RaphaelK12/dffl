/*
	Distance Field Font Library
	
	
	Copyright (c) 2014 Riku Teiril√§

	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

	1. The origin of this software must not be misrepresented; you must not
	   claim that you wrote the original software. If you use this software
	   in a product, an acknowledgment in the product documentation would be
	   appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	   misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.
	
	
	DFFL is a small library (ok, it might be exaggerated to call a single header file a "library") that manages and
	renders fonts stored as signed distance field textures. The idea is from
	http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf
	
	Unlike every other signed distance field text renderer I've seen, this one doesn't require precomputing the distance
	field textures, as the algorithm to find the nearest edge point is fast enough for most purposes.
	
	Include OpenGL headers your self. This header does not include them, as they are somewhat platform and environment
	dependent. Works with OpenGL 3.0 and, as far as I know, doesn't use any features deprecated in any newer version of
	OpenGL. Should also work with OpenGL ES (2.0?), but this hasn't been tested.
	
	
	Usage:
	
	#include <dffl.h++>
	DFFL_LUTS // do this in one source file
	
	...
	
	dffl::Context ctx;
	dffl::Font font(ctx, "absolute font path/Font.ttf");
	font.Load("absolute font path/Chinese.ttf"); // Additional font files can be loaded to include missing glyphs
	
	...
	
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal case, but may be changed for, e.g., texture targets.
	
	...

	ctx.MoveTo(-400, 200); // Unit is one pixel with (0, 0) in the center of the screen, x to right and y up.
	ctx.Size(25);
	ctx.FillColor(1.0f, 1.0f, 1.0f, 0.5f); // Half transparent white
	font.Write("Hello, ");
	ctx.Size(35);
	ctx.FillColor(0.0f, 0.0f, 1.0f, 1.0f); // Blue
	font.Write("World!");
	ctx.Size(12);
	ctx.Smooth(0.5f); // Reduce smoothing from default 1.0 for more readable small text
	ctx.FillColor(1.0f, 1.0f, 1.0f, 1.0f); // White
	ctx.Move(30, 0); // Move 30 pixels forward
	font.Write("Here comes the small print.");
	
	
	FIXME/TODO:
	
	* Computation of space required by for a string rendered in particular font and size.
	
	* No support for negative pitch of FreeType rendered bitmaps. This will be hard to test because I am yet to
	  encounter a bitmap generated by FreeType with a negative pitch.
	
	* Some form of support for right-to-left and vertical text layout.
	
	* I may be using C++11 features not yet supported by all compilers. Should be tested and fixed, at least against
	  Microsoft compilers.
	
	* While this ports easily to both Windows and Apple if compiled against the FreeType library, this should not be
	  required on platforms that have native APIs for managing and rendering font data.
	
	* DistanceFieldGenerator could be optimized a lot, in particular its cache usage. There is also room for smaller
	  performance improvements, but they are not likely to make a big difference. 
	
	* Support for DirectX on Windows. This should be rather straightforward, if laborful, to add.
	
	* Some people have irrational(?) fear of static constructors. An alternative way to handle LUT generation should be
	  implemented to make them feel better.
	
	* Standard C++ exception handling mechanism can be slow and/or unreliable on some (exotic) platforms. An alternative
	  error handling mechanism should be provided.
	
	* A comment or two should be added as long as I still remember what it does.
*/

#include <cmath>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <vector>

#include <ft2build.h> 
#include FT_FREETYPE_H
#include FT_GLYPH_H

namespace dffl
{
	class DistanceLut
	{
		unsigned char *lut;
		
		public:
		
		DistanceLut()
		{
			lut = new unsigned char[128 * 128];
			for (int i = 0; i < 128; i++)
				for (int j = 0; j < 128; j++)
				{
					int distance = (int)std::sqrt((float)(i * i + j * j));
					lut[i + j * 128] = (distance > 127? 128 : distance);
				}
		}
		
		int operator()(int x, int y)
		{
			x = std::abs(x), y = std::abs(y);
			if (x > 127 || y > 127) return 127;
			return (int)lut[x + y * 128];
		}
	};
	
	class HorizontalOrLut
	{
		unsigned char *lut;
		
		public:
		
		HorizontalOrLut()
		{
			lut = new unsigned char[256];
			for (int i = 0; i < 256; i++)
			{
				unsigned char r = 0;
				for (int j = 0; j < 4; j++)
				{
					r |= (((i >> (j * 2)) | (i >> (j * 2 + 1))) & 1) << j;
				}
				lut[i] = r;
			}
		}
		
		unsigned char operator()(unsigned char x)
		{
			return lut[x];
		}
	};
	
	struct SquareBitmap
	{
		int log2side, log2stride;
		unsigned char *data;
		static HorizontalOrLut hor;
		
		SquareBitmap(int log2side)
		{
			this->log2side = log2side;
			log2stride = log2side < 3? 0 : (log2side - 3);
			data = new unsigned char[1 << (log2side + log2stride)];
			std::memset(data, 0, 1 << (log2side + log2stride));
		}
		
		SquareBitmap *ScaleDown(bool negative = false)
		{
			SquareBitmap *result = new SquareBitmap(log2side - 1);
			for (int i = 0; i < 1 << log2side; i++)
				for (int j = 0; j < 1 << log2stride; j++)
				{
					unsigned char b = hor(data[(i << log2stride) + j] ^ (negative? 0xff : 0)) << ((j & 1) * 4);
					int x = j >> 1, y = i >> 1;
					result->data[x + (y << result->log2stride)] |= b;
				}
			return result;
		}

		bool operator()(int x, int y) const
		{
			unsigned char b = data[(x >> 3) + (y << log2stride)];
			return !!((b >> (x & 7)) & 1);
		}		
	};

	class DistanceFieldGenerator
	{
		int levels;
		SquareBitmap *original;
		SquareBitmap **nonemptymap[2];
		static DistanceLut dist;

		bool IsEmpty(bool inside, int level, int u, int v)
		{
			if (!level) return inside ^ (*original)(u, v);
			return !(*nonemptymap[(int)inside][level - 1])(u, v);
		}

		int FindNearest(bool inside, int level, int u, int v, int x, int y, int d)
		{
			if (IsEmpty(inside, level, u, v)) return d;
			if (!level) return std::min(d, dist(u - x, v - y));

			int x0 = (u << level) + (1 << (level - 1));
			int y0 = (v << level) + (1 << (level - 1));
			
			int u0 = (int)(x >= x0);
			int v0 = (int)(y >= y0);

			bool xin = x >= u << level && x < u + 1 << level;
			bool yin = y >= v << level && y < v + 1 << level;
			if (!xin || !yin)
				if (xin && (y - ((v + 1 << level) - 1) > d || (v << level) - y > d)) return d;
				else if (yin && (x - ((u + 1 << level) - 1) > d || (u << level) - x > d)) return d;
			if (!xin && !yin && dist(((u + u0) << level) - x, ((v + v0) << level) - y) >= d) return d;
			
			int u1 = std::abs(x - x0) < std::abs(y - y0)? u0 : 1 - u0;
			int v1 = std::abs(x - x0) < std::abs(y - y0)? 1 - v0 : v0;
			
			int u2 = 1 - u1;
			int v2 = 1 - v1;
			int u3 = 1 - u0;
			int v3 = 1 - v0;
			
			u *= 2, v *= 2, --level;

			d = FindNearest(inside, level, u + u0, v + v0, x, y, d);
			d = FindNearest(inside, level, u + u1, v + v1, x, y, d);
			d = FindNearest(inside, level, u + u2, v + v2, x, y, d);
			d = FindNearest(inside, level, u + u3, v + v3, x, y, d);
			
			return d;
		}
		
		public:
		
		DistanceFieldGenerator(SquareBitmap *original)
		{
			this->original = original;
			levels = original->log2side;
			nonemptymap[0] = new SquareBitmap*[levels];
			nonemptymap[1] = new SquareBitmap*[levels];
			nonemptymap[0][0] = original->ScaleDown(true);
			nonemptymap[1][0] = original->ScaleDown();
			for (int i = 1; i < levels; i++)
			{
				nonemptymap[0][i] = nonemptymap[0][i - 1]->ScaleDown();
				nonemptymap[1][i] = nonemptymap[1][i - 1]->ScaleDown();
			}
		}

		void Generate(unsigned char *buf, int log2side, int log2stride, int width)
		{
			for (int i = 0; i < 1 << log2side; i++)
				for (int j = 0; j < width; j++)
				{
					int x = (j << (levels - log2side)) + (1 << (levels - log2side - 1)) - 1;
					int y = (i << (levels - log2side)) + (1 << (levels - log2side - 1)) - 1;
					
					bool inside = (*original)(x, y);
					
					int d = FindNearest(!inside, levels, 0, 0, x, y, 128);
					d = inside? -d : --d;
					
					buf[j + (i << log2stride)] = (unsigned char)(d + 128);
				}
		}
	};
	
	struct Program
	{
		GLuint program;
	
		Program(const std::string &vshader, const std::string &fshader)
		{
			GLuint vs = glCreateShader(GL_VERTEX_SHADER);
			GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
			const GLchar *vsstr = vshader.c_str(), *fsstr = fshader.c_str();
			glShaderSource(vs, 1, &vsstr, 0);
			glShaderSource(fs, 1, &fsstr, 0);
			glCompileShader(vs);
			glCompileShader(fs);
			program = glCreateProgram();
			glAttachShader(program, vs);
			glAttachShader(program, fs);
			glLinkProgram(program);
			glDetachShader(program, vs);
			glDetachShader(program, fs);
			glDeleteShader(vs);
			glDeleteShader(fs);
		}
		
		void Use()
		{
			glUseProgram(program); 
		}
		
		GLuint operator[](const std::string &name)
		{
			return glGetUniformLocation(program, name.c_str());
		}
	};
	
	struct Boxes
	{
		GLfloat *buffer;
		GLuint vbuf, varray;
		
		Boxes(size_t n = 256)
		{
			buffer = new GLfloat[n * 4 * 6];
			glGenBuffers(1, &vbuf);
			glGenVertexArrays(1, &varray);
		}
		
		void Set(size_t index, float x, float y, float w, float h, float s, float t, float txw, float txh)
		{
			index *= 4 * 6;
			
			buffer[index]      = x;
			buffer[index + 1]  = y;
			buffer[index + 2]  = s;
			buffer[index + 3]  = t;
			
			buffer[index + 4]  = x;
			buffer[index + 5]  = y - h;
			buffer[index + 6]  = s;
			buffer[index + 7]  = t + txh;
			
			buffer[index + 8]  = x + w;
			buffer[index + 9]  = y;
			buffer[index + 10] = s + txw;
			buffer[index + 11] = t;
			
			buffer[index + 12] = buffer[index + 8];
			buffer[index + 13] = buffer[index + 9];
			buffer[index + 14] = buffer[index + 10];
			buffer[index + 15] = buffer[index + 11];

			buffer[index + 16] = buffer[index + 4];
			buffer[index + 17] = buffer[index + 5];
			buffer[index + 18] = buffer[index + 6];
			buffer[index + 19] = buffer[index + 7];

			buffer[index + 20] = x + w;
			buffer[index + 21] = y - h;
			buffer[index + 22] = s + txw;
			buffer[index + 23] = t + txh;
		}
		
		void Render(size_t count)
		{
			glBindBuffer(GL_ARRAY_BUFFER, vbuf);
			glBufferData(GL_ARRAY_BUFFER, count * 6 * 4 * sizeof(GLfloat), buffer, GL_DYNAMIC_DRAW);

			glBindVertexArray(varray);
			glEnableVertexAttribArray(0);
			glBindBuffer(GL_ARRAY_BUFFER, vbuf);
			glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);
			glDrawArrays(GL_TRIANGLES, 0, count * 6);
		}
	};
	
	struct FTError
	{
		int err;
		FTError(int err) { this->err = err; }
	};
	
	class Context
	{
		friend class Font;
		
		const char* vertex_shader =
		"#version 130\n"
		"in vec4 vertex;"
		"out vec2 texcoord;"
		"void main ()"
		"{"
		"	gl_Position = vec4(vertex.xy, 0.0, 1.0);"
		"	texcoord = vertex.zw;"
		"}";

		const char* fragment_shader =
		"#version 130\n"
		"uniform sampler2D tex;"
		"uniform float sf;"
		"uniform float stroke;"
		"uniform vec4 drawcolor;"
		"uniform vec4 fillcolor;"
		"in vec2 texcoord;"
		"out vec4 fragcolor;"
		"void main ()"
		"{"
		"	float d = smoothstep(0.5 + stroke + sf, 0.5 + stroke - sf, texture(tex, texcoord).r);"
		"	float f = smoothstep(0.5 - stroke + sf, 0.5 - stroke - sf, texture(tex, texcoord).r);"
		"	vec4 fillc = vec4((1.0 - (d - f)) * fillcolor.rgb, fillcolor.a * f);"
		"	vec4 drawc = (d - f) * vec4((1.0 - f) * drawcolor.rgb, drawcolor.a);"
		"	fragcolor = drawc + fillc;"
		"}";

		FT_Library ftlib;
		unsigned width, height;
		float x, y;
		float size = 64.0f;
		float smooth = 1.0f;
		float fillcolor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
		float outlncolor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
		float outlnwidth = 0.0f;
		Program *prog;
		
		Boxes boxes;
		
		public:
		
		Context()
		{
			if (int err = FT_Init_FreeType(&ftlib)) throw FTError(err);
			prog = new Program(vertex_shader, fragment_shader);
		}
		
		void Size(float size)
		{
			this->size = size;
		}
		
		void Viewport(unsigned width, unsigned height)
		{
			this->width = width;
			this->height = height;
		}
		
		void MoveTo(float x, float y)
		{
			this->x = x;
			this->y = y;
		}
		
		void Move(float dx, float dy)
		{
			x += dx;
			y += dy;
		}
		
		void FillColor(float r, float g, float b, float a)
		{
			fillcolor[0] = r, fillcolor[1] = g, fillcolor[2] = b, fillcolor[3] = a;
		}
		
		void OutlineWidth(float w)
		{
			outlnwidth = w;
		}
		
		void OutlineColor(float r, float g, float b, float a)
		{
			outlncolor[0] = r, outlncolor[1] = g, outlncolor[2] = b, outlncolor[3] = a;
		}

		void Smooth(float smooth)
		{
			this->smooth = smooth;
		}
	};
	
	class Font
	{
		struct Glyph
		{
			GLuint texture;
			float width;
			float s, t; 
			float offsx, offsy;
			float advance;
		};
		
		Context *context;
		std::vector<FT_Face> faces;
		
		std::vector<GLuint> textures;
		std::map<char32_t, Glyph> glyphs;
		
		unsigned char *buffer;
		unsigned row = 0, pos = 0;
		bool unflushed = false;
		
		void FlushTexture()
		{
			if (!unflushed) return;
			glBindTexture(GL_TEXTURE_2D, *textures.rbegin());
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, 1024, 1024, 0, GL_RED, GL_UNSIGNED_BYTE, buffer);
			
			// This could really be done somewhere else, but it's the easiest to do here
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			
			unflushed = false;
		}
		
		void Generate(char32_t c, FT_Face face, int g)
		{
			FT_Load_Glyph(face, g, 0);
			FT_Render_Glyph(face->glyph, FT_RENDER_MODE_MONO);
			FT_BitmapGlyph glyph;
			FT_Get_Glyph(face->glyph, (FT_Glyph *)&glyph);
			
			SquareBitmap bmap(10);

			for (int i = 0; i < glyph->bitmap.rows; i++)
				for (int j = 0; j < glyph->bitmap.width + 7 >> 3; j++)
				{
					unsigned char b = glyph->bitmap.buffer[i * glyph->bitmap.pitch + j];
					unsigned char r = 0;
					for (int k = 0; k < 8; k++, b >>= 1) r |= (b & 1) << (7 - k);
					bmap.data[4 + j + (32 + i) * 128] = r;
				}
				
			int width = (glyph->bitmap.width + 15 >> 4) + 4;
				
			if (pos + width > 1024)
			{
				pos = 0;
				if (++row == 16)
				{
					FlushTexture();
					GLuint tex;
					glGenTextures(1, &tex);
					textures.push_back(tex);
					row = 0;
				}
			}
			
			DistanceFieldGenerator dfg(&bmap);
			dfg.Generate(buffer + pos + row * 64 * 1024, 6, 10, width);
						
			Glyph gdata;
			gdata.texture = *textures.rbegin();
			gdata.width = (float)(width - 1) / 63;
			gdata.s = ((float)pos + 0.5f) / 1024;
			gdata.t = ((float)(row * 64) + 0.5f) / 1024;
			gdata.offsx = (float)face->glyph->metrics.horiBearingX / 960 / 64 - 1.5f / 64;
			gdata.offsy = (float)face->glyph->metrics.horiBearingY / 960 / 64 - 1.5f / 64;
			gdata.advance = (float)face->glyph->linearHoriAdvance / 960 / 65536;
			
			pos += width;
			
			glyphs[c] = gdata;
			unflushed = true;
		}

		void Add(char32_t c)
		{
			if (glyphs.count(c)) return;
			int f = 0, g;
			while (!(g = FT_Get_Char_Index(faces[f], c))) if (++f >= faces.size()) return;
			Generate(c, faces[f], g);
		}
		
		template<class IT> std::u32string DecodeUTF8(IT i, const IT &e)
		{
			std::u32string utf32;
			while (i != e)
				if (!(*i & 0x80)) utf32 += (char32_t)*i++;
				else if ((*i & 0xe0) == 0xc0)
				{
					char32_t c = ((char32_t)*i++ & 0x1f) << 6;
					utf32 += c | ((i == e)? 0 : (char32_t)*i++ & 0x3f);
				}
				else if ((*i & 0xf0) == 0xe0)
				{
					char32_t c = ((char32_t)*i++ & 0x0f) << 12;
					c |= (i == e)? 0 : ((char32_t)*i++ & 0x3f) << 6;
					utf32 += c | ((i == e)? 0 : (char32_t)*i++ & 0x3f);
				}
				else if ((*i & 0xf8) == 0xf0)
				{
					char32_t c = ((char32_t)*i++ & 0x07) << 18;
					c |= (i == e)? 0 : ((char32_t)*i++ & 0x3f) << 12;
					c |= (i == e)? 0 : ((char32_t)*i++ & 0x3f) << 6;
					utf32 += c | ((i == e)? 0 : (char32_t)*i++ & 0x3f);
				}
				else ++i;
			return utf32;
		}
		
		public:
		
		Font(Context &context)
		{
			this->context = &context;
			buffer = new unsigned char[1024 * 1024];
			GLuint tex;
			glGenTextures(1, &tex);
			textures.push_back(tex);
		}
		
		Font(Context &context, const std::string &path, int index = 0) : Font(context)
		{
			Load(path, index);
		}
		
		void Load(const std::string &path, int index = 0)
		{
			FT_Face face;
			if (int err = FT_New_Face(context->ftlib, path.c_str(), index, &face)) throw FTError(err);
			FT_Set_Char_Size(face, 0, 960 * 64, 72, 72);
			faces.push_back(face);
			if (faces.size() == 1) Generate(0, face, 0);
			FlushTexture();
		}
		
		void Add(const std::u32string &chars)
		{
			for (auto c : chars) Add(c);
			FlushTexture();
		}
		
		void Add(const std::string &text)
		{
			Add(DecodeUTF8(text.begin(), text.end()));
		}

		void Write(const std::u32string &text)
		{
			Add(text);
			
			std::set<GLuint> usedtex; 
			for (auto c : text) usedtex.insert(glyphs.count(c)? glyphs[c].texture : *textures.begin());
			
			context->prog->Use();
			glActiveTexture(GL_TEXTURE0);
			glUniform1i((*context->prog)["tex"], 0);
			glUniform4fv((*context->prog)["fillcolor"], 1, context->fillcolor);
			glUniform4fv((*context->prog)["drawcolor"], 1, context->outlncolor);
			glUniform1f((*context->prog)["stroke"], context->outlnwidth * 960 / 2 / 255 / 100);			
			glUniform1f((*context->prog)["sf"], 960.0f / context->size / 255 * context->smooth);

			float pos;
			for (auto t : usedtex)
			{
				pos = 0.0f;
				int n = 0;
				for (auto c : text)
				{
					const Glyph &glyph = glyphs.count(c)? glyphs[c] : glyphs[0];
					if (glyph.texture == t)
					{
						float x = (context->x + pos + context->size * glyph.offsx) * 2 / context->width;
						float y = (context->y + context->size * glyph.offsy) * 2 / context->height;
						float w = context->size * 2 / context->width * glyph.width;
						float h = context->size * 2 / context->height; 
						context->boxes.Set(n++, x, y, w, h, glyph.s, glyph.t, 63.0f * glyph.width / 1024, 63.0f / 1024);
					}
					pos += glyph.advance * context->size;
				}
				glBindTexture(GL_TEXTURE_2D, t);
				context->boxes.Render(n);
			}
			context->x += pos;
		}
		 
		void Write(const std::string &text)
		{
			Write(DecodeUTF8(text.begin(), text.end()));
		}
	};
}

#define DFFL_LUTS \
	dffl::HorizontalOrLut dffl::SquareBitmap::hor; \
	dffl::DistanceLut dffl::DistanceFieldGenerator::dist;
